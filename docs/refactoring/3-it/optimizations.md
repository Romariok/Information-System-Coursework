# Оптимизации

## Анализ времени выполнения

Для начала мы целых 7 минут с помощью специального запроса из [скрипта](../../../SQL/insertTestData.sql) вставляли тестовые данные в нашу БД. Оценку количества и соотношения строк в таблицах мы проводили ещё во время разработки данного приложения

Далее с помощью Prometheus мы можем посмотреть самые тяжелые запросы по 95-му перцентилю времени ответа командой:

```sql
topk(10,
  histogram_quantile(
    0.95,
    sum by (uri, le) (
      http_server_requests_seconds_bucket{uri!~"/actuator/.*"}
    )
  )
)
```

и увидели следующие результаты:

![График](./1.png)

Благодаря уже имеющимся индексам любой фильтр по продуктам работает быстрее, чем авторизация, причём в 4 раза! Кроме того, видим также довольно медленную обработку запроса при следующих действиях:

- открытие страницы с музыкантами(-ом)
- авторизация
- открытие страницы со статьями

Проанализируем каждую из проблем по отдельности и посмотрим, как можно это решить

### Оптимизация страницы с музыкантами

Основная причина медленной работы страницы с музыкантами заключалась в паттерне N+1 запросов:

- **Список музыкантов** (`MusicianService.getMusician`) загружал страницу сущностей `Musician` через `MusicianRepository.findAll(page)`, а затем
  для *каждого* музыканта отдельно делал запросы в таблицы `musician_genre`, `type_of_musician_musician` и `musician_product` через соответствующие репозитории.
- **Список подписок пользователя** (`UserService.getSubscribedMusicians`) повторял ту же схему: для каждого музыканта в подписках выполнялись отдельные запросы за жанрами, типами и продуктами.

Это приводило к росту количества запросов к БД линейно от числа музыкантов на странице (3 дополнительных запроса на музыканта только по связям, не считая загрузки самих продуктов).

Мы переписали эту логику на батчевую выборку:

- В `MusicianGenreRepository`, `MusicianTypeOfMusicianRepository` и `MusicianProductRepository` добавлены методы `findByMusicianIdIn(List<Long> musicianIds)`, которые делают один запрос с `WHERE musician_id IN (...)` вместо множества одиночных запросов.
- В `MusicianService` добавлен приватный метод `buildMusicianInfoDTOs(...)`, который:
  - собирает все `musician_id` с текущей страницы,
  - одним батчем загружает все жанры, типы и продукты для этих музыкантов,
  - группирует результаты в мапы `musician_id -> список сущностей` и
  - на их основе формирует `MusicianInfoDTO` без дополнительных обращений к БД.
- В `UserService.getSubscribedMusicians` реализована аналогичная батчевая агрегация по списку музыкантов, на которых подписан пользователь.

Таким образом, вместо \(1 + 3 \cdot N\) запросов (страница музыкантов + три запроса по связям на каждого музыканта) теперь выполняется всего 4 запроса независимо от размера страницы. Это уменьшает нагрузку на БД и сокращает время ответа для эндпоинтов, связанных со списком музыкантов.

### Результаты оптимизации

Было:

![Было музыканты](./2.png)

![Стало музыканты](./3.png)

Таким образом, снизили время ответа более чем в 2 раза!

Остальные метрики тоже стали чуть лучше, потому что для оптимизации этой метрики другие запросы тоже пришлось поправить, но об этом далее

### Оптимизация страницы со статьями


